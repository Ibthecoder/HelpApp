1️⃣ Users
User can have different roles: CLIENT, PROVIDER, ADMIN. Clients can make bookings (bookingsAsClient). Providers can offer services and receive bookings (bookingsAsProvider). Users can write reviews (reviews)..

2️⃣ Services
Every Service belongs to a specific provider (providerId). Example: "John's Plumbing Service" — John is the provider. Service also has title, description, price, and a link to bookings. This allows you to list services by provider in the app.

3️⃣ Bookings
Booking links a client, a provider, and a service. The status tracks whether the booking is PENDING, ACCEPTED, REJECTED, or COMPLETED. A booking can optionally have a review.

4️⃣ Reviews
A Review is linked to a specific Booking. Only the client who made the booking can write the review (authorId). Ensures that reviews are tied to actual services received.

5️⃣ Why this schema works well
Provider-specific services: Each provider has their own services.
Flexible bookings: Clients can book any provider’s service.
Data integrity: Relations ensure no invalid data (e.g., a review without a booking).
Scalable: You can add new roles, statuses, or service categories easily.


✩ User model

Relations are consistent:

* bookingsAsClient ↔ Booking.client
* bookingsAsProvider ↔ Booking.provider
* servicesProvided ↔ Service.provider
* reviews ↔ Review\.author

Enum default (CLIENT) is valid.

✩ ServiceType model

* Holds services: Service\[] → correct one-to-many relation.
* Admin can create these types.

✩ Service model

Properly linked to:

* provider via User.servicesProvided
* serviceType via ServiceType.services
* Includes bookings → correct one-to-many with Booking.

✩ Booking model

* Links client, provider, service correctly.
* review? optional → correct for bookings that may or may not have reviews.
* Enum default PENDING is correct.

✩ Review model

* Proper relation to Booking (unique) and User (author).
* Optional comment allowed.

✩ Enums

* Role and BookingStatus look good.
